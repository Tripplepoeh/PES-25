#include "lichtkrant.h"
#include <string.h>

// fontASCII: 8 kolommen per karakter, bit7=top, bit0=bottom
static const uint8_t fontASCII[][8] = {
    // spatie (index 0)
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // A–Z (index 1–26)
    {0x7E,0x88,0x88,0x88,0x88,0x7E,0x00,0x00}, // A
    {0xFE,0x92,0x92,0x92,0x6C,0x00,0x00,0x00}, // B
    {0x7C,0x82,0x82,0x82,0x44,0x00,0x00,0x00}, // C
    {0xFE,0x82,0x82,0x44,0x38,0x00,0x00,0x00}, // D
    {0xFE,0x92,0x92,0x92,0x82,0x00,0x00,0x00}, // E
    {0xFE,0x90,0x90,0x90,0x80,0x00,0x00,0x00}, // F
    {0x7C,0x82,0x82,0x8A,0x5C,0x00,0x00,0x00}, // G
    {0xFE,0x10,0x10,0x10,0xFE,0x00,0x00,0x00}, // H
    {0x82,0x82,0xFE,0x82,0x82,0x00,0x00,0x00}, // I
    {0x04,0x02,0x82,0xFE,0x80,0x00,0x00,0x00}, // J
    {0xFE,0x10,0x28,0x44,0x82,0x00,0x00,0x00}, // K
    {0xFE,0x02,0x02,0x02,0x02,0x00,0x00,0x00}, // L
    {0xFE,0x40,0x20,0x40,0xFE,0x00,0x00,0x00}, // M
    {0xFE,0x20,0x10,0x08,0xFE,0x00,0x00,0x00}, // N
    {0x7C,0x82,0x82,0x82,0x7C,0x00,0x00,0x00}, // O
    {0xFE,0x90,0x90,0x90,0x60,0x00,0x00,0x00}, // P
    {0x7C,0x82,0x8A,0x84,0x7A,0x00,0x00,0x00}, // Q
    {0xFE,0x90,0x98,0x94,0x62,0x00,0x00,0x00}, // R
    {0x64,0x92,0x92,0x92,0x4C,0x00,0x00,0x00}, // S
    {0x80,0x80,0xFE,0x80,0x80,0x00,0x00,0x00}, // T
    {0xFE,0x02,0x02,0x02,0xFE,0x00,0x00,0x00}, // U
    {0xF8,0x04,0x02,0x04,0xF8,0x00,0x00,0x00}, // V
    {0xFE,0x04,0x18,0x04,0xFE,0x00,0x00,0x00}, // W
    {0xC6,0x28,0x10,0x28,0xC6,0x00,0x00,0x00}, // X
    {0xE0,0x10,0x0E,0x10,0xE0,0x00,0x00,0x00}, // Y
    {0x86,0x8A,0x92,0xA2,0xC2,0x00,0x00,0x00}, // Z
    // 0–9 (index 27–36)
    {0x7C,0x8A,0x92,0xA2,0x7C,0x00,0x00,0x00}, // 0
    {0x00,0x42,0xFE,0x02,0x00,0x00,0x00,0x00}, // 1
    {0x46,0x8A,0x92,0x92,0x62,0x00,0x00,0x00}, // 2
    {0x44,0x82,0x92,0x92,0x6C,0x00,0x00,0x00}, // 3
    {0x10,0x30,0x50,0xFE,0x10,0x00,0x00,0x00}, // 4
    {0xF4,0x92,0x92,0x92,0x8C,0x00,0x00,0x00}, // 5
    {0x7C,0x92,0x92,0x92,0x4C,0x00,0x00,0x00}, // 6
    {0x80,0x8E,0x90,0xA0,0xC0,0x00,0x00,0x00}, // 7
    {0x6C,0x92,0x92,0x92,0x6C,0x00,0x00,0x00}, // 8
    {0x60,0x92,0x92,0x92,0x7C,0x00,0x00,0x00}, // 9
    // leestekens (index 37–41)
    {0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00}, // .
    {0x00,0x00,0x10,0x08,0x00,0x00,0x00,0x00}, // ,
    {0x00,0x00,0x10,0x10,0x00,0x00,0x00,0x00}, // :
    {0x00,0x00,0x10,0x10,0x10,0x00,0x00,0x00}, // -
};

static int charIndex(char c) {
    if (c == ' ') return 0;
    if (c >= 'A' && c <= 'Z')  return 1 + (c - 'A');
    if (c >= '0' && c <= '9')  return 27 + (c - '0');
    if (c == '.') return 37;
    if (c == ',') return 38;
    if (c == ':') return 39;
    if (c == '-') return 40;
    return 0;
}

void buildScrollBufferFromString(const char *text, uint8_t *buffer, int *length) {
    int idx = 0;
    for (int i = 0; text[i] != '\0'; i++) {
        int fi = charIndex(text[i]);
        // 8 kolommen font
        for (int col = 0; col < 8; col++) {
            buffer[idx++] = fontASCII[fi][col];
        }
        // 1 lege kolom ertussen
        buffer[idx++] = 0x00;
    }
    *length = idx;
}

extern SPI_HandleTypeDef hspi1;
 
uint8_t lichtkrant_buffer[NUM_MODULES*8][8];

void Lichtkrant_SendAll(uint8_t address, uint8_t data) {
    uint8_t txbuf[NUM_MODULES*2];
    for (int m = 0; m < NUM_MODULES; m++) {
        txbuf[2*m]   = address;
        txbuf[2*m+1] = data;
    }
    HAL_GPIO_WritePin(LOAD_GPIO_Port, LOAD_Pin, GPIO_PIN_RESET);
    HAL_SPI_Transmit(&hspi1, txbuf, sizeof(txbuf), HAL_MAX_DELAY);
    HAL_GPIO_WritePin(LOAD_GPIO_Port, LOAD_Pin, GPIO_PIN_SET);
}


void Lichtkrant_Initcascade(void){
    Lichtkrant_SendAll(0x09, 0x00);
    Lichtkrant_SendAll(0x0A, 0x08);
    Lichtkrant_SendAll(0x0B, 0x07);
    Lichtkrant_SendAll(0x0C, 0x01);
    Lichtkrant_SendAll(0x0F, 0x00);
    for (uint8_t rij = 1; rij <= 8; rij++) {
        Lichtkrant_SendAll(rij, 0x00);
    }
}

void Lichtkrant_UpdateFrame(void){
        for (uint8_t row = 0; row < 8; row++) {
        uint8_t txbuf[NUM_MODULES*2];
        // modules vallen in cascade: eerste bytes gaan naar verste module
        for (int m = 0; m < NUM_MODULES; m++) {
            uint8_t base = (NUM_MODULES - 1 - m) * 8;  // col-offset
            txbuf[2*m]   = row + 1;
            txbuf[2*m+1] = 0;
            for (int bit = 0; bit < 8; bit++) {
                if (lichtkrant_buffer[base + bit][row] & 0x01) {
                    txbuf[2*m+1] |= (1 << (7 - bit));
                }
            }
        }
        HAL_GPIO_WritePin(LOAD_GPIO_Port, LOAD_Pin, GPIO_PIN_RESET);
        HAL_SPI_Transmit(&hspi1, txbuf, sizeof(txbuf), HAL_MAX_DELAY);
        HAL_GPIO_WritePin(LOAD_GPIO_Port, LOAD_Pin, GPIO_PIN_SET);
    }
}

void scrollBuffer32(uint8_t *cols, int len, uint16_t delay_ms) {
    // schuif venster over cols + een leeg einde
    for (int offs = 0; offs < len + NUM_MODULES*8; offs++) {
        // clear frame
        memset(frameBuffer, 0, sizeof(frameBuffer));
        // vul frameBuffer per kolom
        for (int c = 0; c < NUM_MODULES*8; c++) {
            int src = offs + c;
            if (src < len) {
                uint8_t colData = cols[src];
                for (int r = 0; r < 8; r++) {
                    frameBuffer[c][r] = (colData >> (7 - r)) & 0x01;
                }
            }
        }
        MAX7219_UpdateFrame();
        HAL_Delay(delay_ms);
    }
}